#!/usr/bin/env ruby
require 'set'
require 'optparse'
require 'io/console'
require 'tmpdir'


# Helpers for string colorization
class String
  def colorize(color_code)
    "\e[1;#{color_code}m#{self}\e[0m"
  end

  def red
    colorize(31)
  end

  def green
    colorize(32)
  end

  def yellow
    colorize(33)
  end

  def blue
    colorize(34)
  end
end


FILENAME_REGEX = %r{^diff --git a\/(?<filename>[^\s]+)\sb[^\s]+$}
LINE_NUMBER_REGEX = /^@@ -(?<a_line>\d+)(,(\d+))* \+(?<b_line>\d+)(,(\d+))* @@/
REMOVED_LINE_REGEX = /^-/

MATCHERS = {
  /\.rb$/ => {
    lang: 'Ruby',
    matchers: [
      {
        name: "require 'byebug'",
        regex: /^\+require ['"]byebug['"]/
      },
      {
        name: "require 'debugger'",
        regex: /^\+require ['"]debugger['"]/
      },
      {
        name: 'debugger',
        regex: /^\+\s*debugger/
      },
      {
        name: 'puts',
        regex: /^\+\s*puts/
      },
      {
        name: 'print',
        regex: /^\+\s*print/
      }
    ]
  },
  /\.jsx?$/ => {
    lang: 'JavaScript',
    matchers: [
      {
        name: 'debugger',
        regex: /^\+\s*debugger/
      },
      {
        name: 'console.log',
        regex: /^\+\s*console\.log/
      }
    ]
  },
  /\.py$/ => {
    lang: 'Python',
    matchers: [
      {
        name: 'print',
        regex: /^\+\s*print\s+['"]/
      },
      {
        name: 'import pdb',
        regex: /^\+import pdb/
      },
      {
        name: 'pdb.set_trace',
        regex: /^\+\s*pdb\.set_trace/
      },
    ]
  }
}.freeze

FILENAME_LANGS = {
  'Gemfile'   => 'Ruby',
  'Rakefile'  => 'Ruby',
  'Guardfile' => 'Ruby',
}.freeze

@options = {
  regex: nil,
  lang: nil,
  patch: false,
  confirm: true,
}

OptionParser.new do |opts|
  opts.banner = 'Usage: git-remove-debug [options] [files]'

  opts.on '-r REGEX',
          '--regex=REGEX',
          'Use a custom regex for changed lines' do |r|
    @options[:regex] = r
  end
  opts.on '-l LANGUAGE',
          '--lang=LANGUAGE',
          'Use the regex for the given language' do |l|
    @options[:lang] = l
  end
  opts.on '-p',
          '--patch',
          'Asks you to confirm the deletion of each matching line' do |p|
    @options[:patch] = true
  end
  opts.on '-f',
          '--force',
          'Does not prompt before deleting lines' do |p|
    @options[:confirm] = false
  end

  opts.on_tail('-h', '--help', 'Show this message') do
    puts opts
    exit
  end
end.parse!

def get_char
  char = STDIN.getch
  if char == "\u0003"
    puts '^C'
    exit(1)
  end
  puts char
  char
end

def find_matchers_for_lang(lang)
  MATCHERS.each do |_, matchers|
    # Case insensitive compare on language name
    next unless lang.casecmp(matchers[:lang]).zero?
    return matchers
  end
  nil
end

def find_matchers_for_lang_option
  return nil unless @options[:lang]
  matchers = find_matchers_for_lang(@options[:lang])
  if matchers.nil?
    raise %(
      We do not have a built-in regex for the "#{@options[:lang]}" language.
      Please feel free to add one and submit a PR.
    )
  end
  matchers
end

def find_matchers_for_regex_option
  return nil unless @options[:regex]
  {
    matchers: [{
      regex: Regexp.new(@options[:regex])
    }]
  }
end

def matchers_for_options
  find_matchers_for_regex_option || find_matchers_for_lang_option
end


@filename = nil
@line_number = nil
@matchers = matchers_for_options
@has_default_matchers = !@matchers.nil?

@lines_to_delete = {}


# Find the regex for the given file
def find_matchers_for_filename(filename)
  MATCHERS.each do |file_regex, matchers|
    next unless @filename[file_regex]
    return matchers
  end

  lang = FILENAME_LANGS[filename]
  return if lang.nil?
  find_matchers_for_lang(lang)
end

def find_filename_and_matchers(line)
  match = line.match(FILENAME_REGEX)
  return false unless match

  @filename = match[:filename]
  @line_number = nil


  @matchers = find_matchers_for_filename(@filename) unless @has_default_matchers

  true
end

def find_line_number(line)
  # Find the line number
  match = line.match(LINE_NUMBER_REGEX)
  return false unless match
  @line_number = match[:b_line].to_i
  true
end

def print_deleted_line(filename, line_number, line)
  puts
  puts "#{filename}:#{line_number}".yellow
  puts line.green
  puts
end

def stage_line_for_deletion(line)
  @lines_to_delete[@filename] ||= []
  @lines_to_delete[@filename] << {
    number: @line_number,
    line: line
  }
end

def delete_all_matches
  # Create a temp directory for backup files
  Dir::Tmpname.create('git-remove-debug') do |temp_dir|
    @lines_to_delete.each do |filename, deleted_lines|
      temp_path = File.join(temp_dir, filename)
      FileUtils::mkdir_p File.dirname(temp_path)
      FileUtils.cp(filename, temp_path)

      puts "Backed up #{filename} to: #{temp_path}"

      # Rewrite the file without deleted lines.
      deleted_line_numbers = Set.new(deleted_lines.map { |line| line[:number] })

      original_lines = File.read(filename).split("\n")
      File.open(filename, 'w') do |f|
        original_lines.each_with_index do |line, i|
          f.puts line unless deleted_line_numbers.include?(i + 1)
        end
      end
    end
  end
end

def total_deleted_lines
  total_lines = @lines_to_delete.keys.reduce(0) do |s, key|
    s + @lines_to_delete[key].count
  end
end

# I think we should always confirm again, even in patch mode.
def confirm_deletion
  total_lines = total_deleted_lines
  if total_lines.zero?
    puts 'Nothing to delete.'
    exit
  end

  puts "\n\n"
  puts '================================================================'
  puts "    Ready to delete #{total_lines} debugging statements in #{@lines_to_delete.count} file(s):"
  puts '================================================================'

  @lines_to_delete.each do |filename, lines|
    lines.each do |line_data|
      print_deleted_line(filename, line_data[:number], line_data[:line])
    end
  end

  print 'Delete all lines? [y,n]? '.blue
  if get_char == 'y'
    delete_all_matches
    return
  end

  puts 'Aborted.'
end

def confirm_line_deletion(line)
  print 'Delete this line [y,n,d,q]? '.blue
  char = get_char

  case char.downcase
  when 'y'
    stage_line_for_deletion(line)
  when 'q' then exit
  when 'd'
    confirm_deletion
    exit
  when 'n'
    puts "Skipping #{@filename}:#{@line_number}"
  else
    # Invalid response, so ask again.
    confirm_line_deletion(line)
  end
end

def run_patch_prompt(line)
  print_deleted_line(@filename, @line_number, line)
  confirm_line_deletion(line)
end

def find_matching_line(line)
  return unless @matchers[:matchers].find do |matcher|
    line[matcher[:regex]]
  end

  if @options[:patch]
    run_patch_prompt(line)
  else
    stage_line_for_deletion(line)
  end
end


args = ARGV.join(' ')
git_diff = `git diff --unified=0 #{args}`.split("\n")

git_diff.each do |line|
  next if find_filename_and_matchers(line)

  # Just skip this whole file if we don't have any regex for it
  next if @matchers.nil?

  next if find_line_number(line)

  # Keep going until the line number has been set.
  next if @line_number.nil?

  find_matching_line(line)

  # Increment the line number for the next run.
  @line_number += 1 unless line[REMOVED_LINE_REGEX]
end

if @options[:confirm]
  confirm_deletion
else
  puts "Deleting #{total_deleted_lines} debugging statements in #{@lines_to_delete.count} file(s)..."
  delete_all_matches
end
